# c\#
## 基本语法知识点
### 语句语法：
`Console.WriteLine`与`Console.Write`的区别：
- `Console.WriteLine`输出语句后会自动换行；
- `Console.Write`输出语句后不会自动换行；

### 引用类型
引用`不包含`变量存储的`实际数据`，而是`包含`对变量的`引用`  
1. 对象(Object)类型  
`Object类型`是c\#通用类型系统中所有数据类型的`终极基类`，所以对象类型可以被分配任何其他类型（值类型，引用类型，预定义类型或用户自定义类型）的值，但是分配值之前，需要先进行`类型转换`。  
`装箱`：当一个值类型转换为对象类型时，则被称为`装箱`；  
`拆箱`：当一个对象类型转换为值类型时，被称为`拆箱`；<br/>
```js
object obj;
obj = 100; // 这是装箱
```
2. 动态(Dynamic)类型  
可以存储`任何类型`的值在动态数据类型变量中。这些变量的`类型检查`是在`运行时`发生的。  
例如
```js
//dynamic <variable_name> = value;
dynamic d = 20;
```
动态类型与对象类型相似，但是`对象类型`变量的`类型检查`是在`编译时发生`的，而`动态类型`变量的`类型检查`是在`运行时发生`的。  
3. 字符串(String)类型  
字符串类型允许给变量分配`任何字符串值`，它是从对象类型派生而来。  
字符串类型的值可以通过两种形式进行分配：`引号`和`@引号`。  
**c\#中string字符串的前面可以加@（称作`逐字字符串`）将转义字符（\）当做普通字符对待**  
**@ 字符串中可以任意换行，换行符及缩进空格都计算在字符串长度之内。**
```js
//逐字字符串：转义符
string filename = @"c:\temp\newfile.txt";
Console.WriteLine(filenaame);

//逐字字符串：多行文本
string multiLine = @"This is a
multiline paragraph.";
Console.WriteLine(multiLine);

//非逐字字符串
string escapedFilename = "c:\temp\newfile.txt";
Console.WriteLine(escapedFilename);
```
输出结果：
```js
c:\temp\newfile.txt

This is a
multiline paragraph.

c:    emp
ewfile.txt
```

### c\#类型转换

c\# 中的类型转换可以分为两种：`隐式转换`和`显式转换`。
#### 隐式转换
隐式转换是指将一个 `较小范围的数据类型`转换为`较大范围的数据类型`时，编译器会`自动完成`类型转换，这些转换是 C# 默认的以安全方式进行的转换, `不会导致数据丢失`。
#### 显示转换
显式类型转换，即`强制类型转换`。  
显式转换是指将一个`较大范围的数据类型`转换为`较小范围的数据类型`时，或者将一个对象类型转换为另一个对象类型时，需要使用强制类型转换符号进行显示转换，强制转换会`造成数据丢失`。

### c\#变量

c\#中提供的基本值类型包含以下几种：  
**整数类型、浮点数类型、十进制类型、布尔类型、空类型**

### c\#可空类型（Nullable）
c\# 提供了一个特殊的数据类型，`nullable` 类型（可空类型），可空类型可以表示其基础值类型正常范围内的值，再加上一个 `null`值。
>例如，Nullable< Int32 >，读作"可空的 Int32"，可以被赋值为 -2,147,483,648 到 2,147,483,647 之间的任意值，也可以被赋值为 null 值。类似的，Nullable< bool > 变量可以被赋值为 true 或 false 或 null。

#### c\#单问号与双问号

`？`单问号用于对`int`、`double`、`bool`等无法直接赋值为null的数据类型进行null的赋值，意思是这个数据类型是`Nullable`类型的。
```js
int i; //默认值0
int? ii; //默认值null
```
`??`双问号（`Null 合并运算符`）用于判断一个变量`为null`的时候返回一个`指定的值`。  
`Null 合并运算符`用于定义`可空类型`和`引用类型`的`默认值`。Null 合并运算符为类型转换定义了一个`预设值`，以防可空类型的值为`null`。Null 合并运算符把操作数类型`隐式转换`为另一个可空（或不可空）的值类型的操作数的类型。
>如果第一个操作数的值为 null，则运算符返回第二个操作数的值，否则返回第一个操作数的值。下面的实例演示了这点：
```js
using System;
namespace CalculatorApplication
{
   class NullablesAtShow
   {
         
      static void Main(string[] args)
      {
         
         double? num1 = null;
         double? num2 = 3.14157;
         double num3;
         num3 = num1 ?? 5.34;      // num1 如果为空值则返回 5.34
         Console.WriteLine("num3 的值： {0}", num3);
         num3 = num2 ?? 5.34;
         Console.WriteLine("num3 的值： {0}", num3);
         Console.ReadLine();

      }
   }
}
```

### String与StringBuilder的区别

`String`是存储在静态存储区，字符串内容是不会被改变的，每次对字符串进行操作，返回的都是一个新的字符串；
`StringBulider`是存储在堆栈上的，本质是一个字符数组，字符串内容会被改变；

如果对一个字符串进行频繁的操作变动（增删操作），使用StringBuilder更合适，原因如下：  
>String类变动是，每次都是开辟新的存储区域，存放操作过后的新字符串，而StringBuilder类变动时是在原字符串的基础之上进行增删，不会频繁的开辟新的存储区域。

### 委托

c\#中的委托类似于C语言C++中的指针，是存有对某个方法的引用的引用类型变量。如果我们把`方法`当做`参数`来传递的话，就要用到`委托`。简单来说`委托`是一个`引用类型`，这个类型可以赋值一个`方法的引用`。

`Action委托`只能指向`没有返回值`的`方法`，参数可以有多个，类型也可以不同，但是不能有返回值；  
`Func委托`必须只想`有返回值`的`方法`，与Action委托正好相反，参数也可以是多个，类型不限；

#### 多播委托
`委托对象`可使用`"+"`运算符进行`合并`，一个合并委托调用它所合并的两个委托。只有`相同类型`的委托`可以合并`。`"-"`运算符可从合并委托中`移出`组件委托。

#### 委托事件
当`委托`被声明为`事件event`时，要注意两点：  
1. 外部使用委托时只能`+=`或`-=`进行增删委托方法，不能`赋值`=`；
2. 委托声明event后委托只能在`类内部调用`，不能在类外部进行调用；
